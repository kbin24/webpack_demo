### 前端工程化

#### CommonJS

* 该规范模块是同步的，只有加载完成，才能执行后续操作

* 文件即模块，文件内的所有代码都运行在独立的作用域中，因此不会污染全局空间
* 模块可以被多次引用、加载。在第一次加载时，会被缓存，之后都从缓存中直接读取结果
* 加载某个模块，就是引入该模块的**module.exports**属性
* **module.exports**属性输出的是值的拷贝，一旦这个值被输出，模块内再发生变化也不会影响到输出的值
* 模块按照代码引入的顺序进行加载
* 注意**module.exports**和**exports**的区别，**module.exports**导出整个对象，**exports**导出具体的名称，使用时需要知道该导出的具体名称

##### CommonJS规范如何作用代码在浏览器实现呢

​	其实就是实现**module.exports**和**require**方法，实现思路：根据**require**的文件路径加载文件内容并执行，同时将对外接口进行缓存。因此我们需要定义一个**module**对象。代码如下：

```
let module = {}
module.exports = {}
```

​	接着借助立即执行函数，对**module**和**module.exports**对象进行赋值。如下：

```
(function(module,exports){
	//...
}(module,module.exports))
```

#### AMD

* 该规范是异步加载的，该规范规定了如何定义模块，如何对外输出，如何引入依赖。这一切都需要引入代码去实现，因此一个著名的库----require.js应运而生，require.js的实现很简单：通过**define**方法，将代码定义为模块，通过**require**方法，实现代码的模块加载。事实上，**require.js**也是借助一个立即执行函数来实现的。
* **define**和**require**就是require.js在全局注入的函数

#### CMD

* **CMD**规范整合了**CommonJS**和**AMD**规范的特点，**CMD**规范的实现为**sea.js**

##### AMD和CMD的两个主要区别如下：

* **AMD**需要异步加载模块，而**CMD**在加载模块时，可以通过同步的形式(require)，也可以通过异步的形式(require.async)
* **CMD**遵循依赖就近的原则，**AMD**遵循依赖前置原则，也就是说，在**AMD**中，我们需要把模块内所需要的依赖都提前声明在依赖数组中，而在**CMD**中，我们只需要在具体代码逻辑内，使用依赖前，引入依赖的模块即可

#### UMD

* 它可以允许在环境中同时使用**AMD**规范与**CommonJs**规范，相当于一个整合的规范。该规范的核心思想在于利用立即执行函数根据环境来判断需要的参数类别。譬如，UMD在判断出当前模块遵循**CommonJs**规范时，模块代码就会以如下的方式执行

  ```
  function(factory){
  	module.exports = factory()
  }
  ```

* 如果**UMD**判断出当前模块遵循**AMD**规范，则函数的参数就会变成**define**，使用**AMD**规范，具体代码如下：

  ```
  (function(root,factory){
  	if(typeof define === 'function' && define.amd){
  		//AMD规范
  		define(['b'],factory);
  	}else if(typeof module === 'object' && module.exports){
  		//....
  	}
  })()
  ```

#### ES模块

​	**ES模块**的设计思想是尽量静态化，这样能保证在编译时就能确定模块之间的依赖关系，每个模块的输入和输出变量也都是确定的；而**CommonJs**和**AMD**模块无法保证在编译时就确定这些内容，它们都只能在运行时确定。

##### ES模块为什么要设计成静态的

​	将**ES模块**设计成静态的，一个最明显的优势是，通过静态分析，我们能够分析出导入的依赖。如果导入的依赖没有被使用，我们便可以通过**tree shaking**等手段减少代码体积，进而提升运行性能。这就是基于**ESM**实现**tree shaking**的基础

​	静态性需要规范去强制保证，因此**ES模块**规范不像**CommonJs**规范那样灵活，其静态性会带来如下一些限制：

* 只能在文件顶部引入依赖
* 导出的变量类型受到严格限制
* 变量不允许被重新绑定，引入的模块名也只能是字符常量，即不可以动态确定依赖

##### ES的export和export default

​	**ES模块**导出有**export**和**export default**两种，这里建议减少使用**export default**导出，一方面是**export default**会导出整体对象结果，不利于通过**tree shaking**进行分析；另一方面是因为**export default**导出的结果可以随意命名变量，不利于团队统一管理。